							-*- mode: outline -*-


* Support for option aliases
An option could have several names instead of just one.

* Support for multiple environment variables
An option could be associated with a list of environment variables instead of
just one.

* Support for value post-processing
I'm especially thinking about multiple environment variable support, but maybe
elsewhere. For instance, we could implement a --debug opton associated with
a DEBUG env var, and also/or with a NDEBUG env var for which we should
complement the conversion. Now the question is do we want to post-process the
conversion value, the initial string value, or both ?

Another related thought: value post-processing could mean value
canonicalization (especially useful when in the debugger, you're invited to
provide another value). For instance, in path options, the converter handles
~/ abbreviations. However, this is not valid when typing a value directly,
which is a shame.

* Treat empty env vars as options called without their (optional argument)
With the restriction that there's no notion of an env var set without
argument. There's only empty arguments. This will lead to problems if the
option is supposed to accept empty strings.

* Support for dynamic default value / fallback
computed at run-time from a lambda expression for instance.

* Support for a complete cmdline syntax description
Currently, there's just the notion of non-Clon remainder, but some programs
might want to alternate options and non-option stuff, while still managing
those parts with Clon.

* Extend abbreviated option matching to dash-parts
e.g. --f-n == --family-name.

* Extend the path option class to accept wildcards in pathnames
and expand them into actual directories.

* Extend the path option class to not ignore a final colon
Like TeX variables, this would mean to append the built-in path after the
user-specified part.

* Study POSIX behavior for cmdline options
See if we can provide a POSIX compliant mode, that would be triggered by
POSIXLY_CORRECT, POSIX_ME_HARDER, or other means (cmdline options?)

* Support for shell completion
Implement automatic generation of whatever is needed for shell completion of
options (zsh in particular, zcomp I think it is).

* Finer grain for conversion errors
Currently, converters are supposed to raise an invalid-argument error, but we
might want something more powerful (like handling a whole conversion-error
hierarchy). For instance, when a path is wrong, we would like to provide a
restart for modifying just the faulty path element. However, this is not
currently possible because invalid-argument errors are trapped and converted
to invalid-cmdline-argument or invalid-environment-value ones. So we can't
benefit from all the restarts that we could define at the lower-level.

* Inputing nil
Currently, nullablep is mainly used for options with optional arguments, in
which case we might use nil as a fallback or a default value. However, only
the PATH option class can lead to a null value from user input (stropts and
enums can't). Should we change this, or just let the user provide new option
classes to do so ?

* Better detection of minus-packs
When parsing a short call, we try a known option, a known option with a sticky
argument, a pack, and then barf. Sometimes, a pack can be mistaken for a known
option with a sticky (however invalid) argument. For instance, suppose we have
a -d switch and a -v flag. Using -dv will lead to an invalid argument to -d,
whereas the user probably meant -v -d (or -vd which works). We could improve
the detection of this situation by catching the invalid argument error, and
then trying a pack instead of immediately reporting the error.

* Extend the [items-]separator face property
Item separation would ideally depend on what's before or after the item being
displayed. 
